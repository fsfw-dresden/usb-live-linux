#!/bin/bash
. "$(dirname $(realpath "${0}"))/functions.sh"
. "$(dirname $(realpath "${0}"))/functions.bash"
cd_repo_root

# give some rudimentary help if requested
case "${1}" in
    "-h")
        ;&
    "--help")
        print_info "usage is  ${0} [TARGET [ISO_FILE [INSTALL_VARIANT [SIZE_MB_PARTITION_FAT32]]]]"
        print_info "\tTARGET: can be either a pre-allocated image file or a block or loop device."
        exit
        ;;
esac

# install required tools
sudo apt install fatattr f2fs-tools libcdio-utils dialog ccze

release_loop_device() {
        # Skip in case loop device is released already (should not happen)
        losetup "${DEVICE}" > /dev/null || return

        print_info "Releasing ${DEVICE}"

        grep ${DEVICE} /proc/mounts && print_warn "Mounted partitions still around, to be released after unmounting exit trap has run"

        losetup --verbose --detach ${DEVICE}
}

setup_loop_device() {
        # connect file to loop device
        DEVICE=$(losetup --partscan --verbose --show --nooverlap --find "${1}")

        # free loop device again on premature script termination
        trap "release_loop_device" EXIT SIGHUP SIGQUIT SIGTERM
}

# First parameter can be an image file or loop device
if [ -n "${1}" ]
then
        # Is it a block device?
        if [ -b "${1}" ]
        then
                # just pass it on
                DEVICE="${1}"
        # or is it a writable, pre-allocated image file?
        elif [ -w "${1}" ]
        then
                setup_loop_device "${1}"
        else
                ls -lahd "${1}"
                lstrail "${1}"
                die_with_error 5 "What is ${1}, a pineapple?"
        fi

        # drop argument one, move up the following
        shift
else
        PRELIMINARY_IMAGE="build/installation.temp.img"
        # FIXME: this should be SIZE_MB_PARTITION_FAT32 + a bit bigger than SIZE_LIVE_SYSTEM ðŸ¤”
        SIZE_MB_IMAGE=$((14 * 2**10))

        # create image file
        truncate --size="${SIZE_MB_IMAGE}M" "${PRELIMINARY_IMAGE}"

        setup_loop_device "${PRELIMINARY_IMAGE}"
fi

# Invoke stick-install in same shell process
source scripts/stick-install "${DEVICE}" "${@}"

printf '\n'
print_info "Returned from stick-install script"

# This has overriden the release_loop_device and set unmount exit traps
# that will only be run at the exit of this script. However, linux is
# cool and we can move the image, then unmap its loop device, then
# unmount the partitions afterwards. Blessed are thee who cut corners.
release_loop_device

if [ -n "${PRELIMINARY_IMAGE}" ]
then
        # cut off file ending of ISO and append .img.gz
        TARGET_IMAGE=${LIVE_IMAGE##*/}
        TARGET_IMAGE=${TARGET_IMAGE%%.iso}
        TARGET_IMAGE="artifacts/${TARGET_IMAGE%%.hybrid}.img.gz"

        # prevent excessive space usage
        (
                cd build
                print_info "Cleaning up after live-build, disk space is finite..\n$(df -h .)"
                lb clean --color
                print_info "Finished cleaning, disk space now:\n$(df -h .)"
        )

        # (Other compression algorithms have been tried and found to be much slower, providing
        # very little extra download volume savings because the ISO itself is already compressed)
        print_info "Multi-core gzipping the disk image to create release product"
        pigz --independent --blocksize 1024 --stdout < "${PRELIMINARY_IMAGE}" | pipemeter > "${TARGET_IMAGE}"

        print_info "generating checksum"
        sha256sum "${TARGET_IMAGE}" > "${TARGET_IMAGE}.sha256sum"

        # and remove the uncompressed temp image
        rm -v "${PRELIMINARY_IMAGE}"
else
        TARGET_IMAGE="${DEVICE}"
fi

print_success "Finished distribution image at ${TARGET_IMAGE}, enjoy."
